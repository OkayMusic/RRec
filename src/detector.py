import server
import struct
import numpy as np
from time import sleep


class Detector(server.Server):
    def __init__(self, mode, binary=None):
        # call server's __init__ method
        super(Detector, self).__init__(mode, binary)
        self._main_image = None

    # definition of the main_image property:
    @property
    def main_image(self):
        return self.image_request(self.rows, self.cols)

    @main_image.setter
    def main_image(self, value):
        if type(value) == str:
            self.load_file(value)
        elif type(value) == np.ndarray:
            assert value.dtype == np.uint8,\
                "Array main_image must have dtype uint8"
            self.rows, self.cols = value.shape
            self.load_array(value)
        else:
            raise TypeError(
                "main_image must be set to a string or a numpy array")

    def equalize(self):
        self._send_instruction(server.Server.equalize)
        if self.read(4) != server.Server.success:
            print "(PYTHON): Error in equalize"
            print self.readline()

    def calculate_background(self, brightness_variance):
        if type(brightness_variance) != int:
            raise TypeError("Arg to calculate_background must be an integer")
        else:
            self._send_instruction(server.Server.calculateBackground)
            self.request(struct.pack('i', brightness_variance))

            if self.read(4) != server.Server.success:
                print "(PYTHON): Error in calculate_background"
                print self.readline()

    def calculate_signal(self, signal_size):
        if type(signal_size) != int:
            raise TypeError("Arg to calculate_background must be an integer")
        else:
            self._send_instruction(server.Server.calculateSignal)
            self.request(struct.pack('i', signal_size))

            response = self.read(4)
            if response != server.Server.success:
                print "(PYTHON): Error in calculate_signal"
                print "Response:", struct.unpack('i', response)[0]

                print "Instruction received, ", self.readline()

    def calculate_significance(self, sigma):
        if type(sigma) != float and type(sigma) != int:
            raise TypeError(
                "Arg to calculate_background must be an int or a float")
        else:
            self._send_instruction(server.Server.calculateSignificance)
            self.request(struct.pack('d', sigma))
            response = self.read(4)
            if response != server.Server.success:
                print "(PYTHON): Error in calculate_significance"
                print "Response:", struct.unpack('i', response)[0]

                print "Instruction received, ", self.readline()

    def cluster(self):
        self._send_instruction(server.Server.cluster)

        response = self.read(4)
        if response != server.Server.success:
            print "(PYTHON): Error in cluster"
            print "Response:", struct.unpack('i', response)[0]
            print "Instruction received, ", self.readline()
        else:
            # now we need to parse the response sent from the C++ end
            # get the total number of bytes (CURRENTLY UNUSED)
            num_bytes = struct.unpack('i', self.read(4))[0]

            # get the total number of different clusters
            num_clusters = struct.unpack('i', self.read(4))[0]

            # make a list to store the clusters in
            clusters = range(num_clusters)

            for i in range(num_clusters):
                # grab the number of core points from the C++ end
                num_core_points = struct.unpack('i', self.read(4))[0]
                # now grab the core points themselves, saving as a numpy array
                core_points = np.fromstring(self.read(2 * num_core_points),
                                            dtype=np.int32,
                                            count=num_core_points)

                core_points = np.reshape(core_points, (num_core_points, 2))

                # now grab the number of outer points from the C++ end
                num_outer_points = struct.unpack('i', self.read(4))[0]
                outer_points = np.fromstring(self.read(2 * num_outer_points),
                                             dtype=np.int32,
                                             count=num_outer_points)

                outer_points = np.reshape(outer_points, (num_outer_points, 2))

                # store these guys in a cluster, in clusters
                clusters[i] = Cluster(core_points, outer_points)

            return clusters


class Cluster(object):
    """
    Handy container for the clusters generated by detector's cluster method.
    """

    def __init__(self, core_points, outer_points):
        # simply grab the core and outer points
        self.core_points = core_points
        self.outer_points = outer_points
